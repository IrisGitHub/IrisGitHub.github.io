[{"title":"vue tree","date":"2017-07-25T08:30:09.000Z","path":"2017/07/25/vue tree/","text":"","categories":[{"name":"Font-end","slug":"font-end","permalink":"https://irisgithub.github.io/categories/font-end/"}],"tags":[]},{"title":"Vue.js使用","date":"2017-05-26T01:41:27.000Z","path":"2017/05/26/入坑Vue-js/","text":"又有一个多月没写博客了，这篇记录一下最近一个月忙的事情——将使用AngularJS(v1.5.4)框架写的后台换成Vue.js(v2.2.6)啦~巨开心！至于我为什么换,大概是因为每次版本迭代不想按原来的方式改写一遍？时间还算充足？浏览器支持很宽松？想体验ES6写法？听说Vue很棒棒哇？想集齐四大法宝(JQuery/AngularJS/Vue.js/React)……主要原因应该是后台就我一个人在做，想怎么做就怎么做吧~哈哈= =Vue框架使用非常方便，一如它所宣称的轻量高效。而且它的官方文档超级清晰，api对于本菜来说也够用。之前用过几个月的Angular,文档到现在还没有全部看完（嗯，可能我比较懒…但它的东西真的多的不要不要的），但是Vue,它的文档我已经刷了好几遍（闲来无事刷文档）= =对于我这种准备学习一门语言或框架之前往往需要先完完整整过一两遍比较全的书或文档，才能放心开始学习的人来说，简直不要太棒！嗯，少说废话，进入正题。首先搭一个框架，做好准备工作。用vue-cli脚手架工具(npm install vue-cli -g)，初始化项目(vue init webpack-simple admin)很快得到admin项目下的完整目录： 详细的网上有教程，其中build和config里面放的是一些配置文件(主要是webpack的，用于打包),dist中放的是开发好的目录，如果要直接放在服务器中访问，需要简单修改一下config文件中的index.js,static放静态资源，src就是我们的开发目录啦。除了vue-cli帮我们安装的一些npm包，由于项目需要，另外引入一些工具 123456789101112131415\"dependencies\": &#123; // 解决http请求 \"axios\": \"^0.16.1\", // 解决Babel对于一些api(如Promise等)不转码的问题 \"babel-polyfill\": \"^6.23.0\", // 强大的时间操作工具 \"moment\": \"^2.18.1\", // 简单的tooltip \"v-tooltip\": \"^2.0.0-beta.4\", \"vue\": \"^2.2.6\", // vue 官方路由 \"vue-router\": \"^2.3.1\", // vue官方状态管理模式 \"vuex\": \"^2.3.1\"&#125;, 其中，vuex和vue-router都有官方文档，十分详细。引入axios是因为vue不像angular，angular提供的$http服务同服务端通信，相比vue-resource,官方推荐强大的axios！用上babel-polyfill工具，因为想使用一些ES6新的api，真想把它们统统都夸一遍 = =看一下项目目录： component: 一些组件(toast,tree,modal,avatar),由于不想引入大而全的库(很多东西不需要)，模式组件源于自己写写改改。directive: 一些指令(v-focus)filter: 一些过滤器(时间、文件大小，操作记录等等)，另外，可直接在组件内部使用computed,有时候它更好用。libs: 一些工具，引用库router: 配置vue路由service: 所有http请求，按照原来在angular框架时师傅教的，将所有api独立出来，感觉好写好改好查找。store: vue的状态管理，我主要放了个人信息和组织结构树信息，方便管理数据views: 所有路由页(因为在做单页应用，在只用component还是用部分router两种模式比较了一下，发现都差不多，为了用上全家桶，用上router)展开的就不放了，因为文件特别多 = =一个简单的component样式： 未完，待续…… —-2018-3-1 更新—- 待续？用完三个框架，感觉Vue最方便好用，简单易入门，解决了数据绑定、组件开发、页面路由等痛点，配套Vuex解决数据管理，差不多了，对于我之前写的小项目来说，好用，没毛病… 有机会还会再用，好评。(^o^)/~","categories":[{"name":"Font-end","slug":"font-end","permalink":"https://irisgithub.github.io/categories/font-end/"}],"tags":[{"name":"JavaScript","slug":"js","permalink":"https://irisgithub.github.io/tags/js/"}]},{"title":"一次http请求","date":"2017-04-17T10:13:27.000Z","path":"2017/04/17/一次http请求/","text":"好久没有写博客了，记录几天前的一个bug，顺便回顾一些之前学的HTTP知识。客户之前要求浏览器支持360和chrome，对版本没有什么要求。想到360极速模式使用的webkit内核，平常代码运行在又chrome上，我感觉可以任性了！但是最近客户改需求需要运行在IE10及以上，小伙伴们开始在IE10上测试。其中一处bug：某次HTTP 请求在chrome上返回200，但在IE10上返回401。在chrome中运行，HTTP 请求详细信息截图如下： 在IE10下HTTP请求响应码返回401，表示身份信息有问题，请求失败： 查看request header： 发现设置在headers中的的authorization字段不见了，在chrome上存在authorization 字段,那么IE10上应该存在，为什么找不到？看到桌面绿色的fiddler，想到它可以抓到很多HTTP 信息，可能会得到其他有用的信息。运行fiddler ，找到目标session： 得到IE10下详细的返回信息： 所以，authorization还是有的，只是IE10没有显示出来，而且变成了Authorization，首字母大写；应该是后端验证出现问题，将bug报给后端被解决。 HTTP基础知识(HTTP basics)一次完整的请求过程：1.域名解析2.建立TCP连接，三次握手3.Web浏览器向Web服务端发送HTTP请求报文4.浏览器解析HTML代码，并请求HTML代码中的资源6.浏览器对页面进行渲染呈献给用户7.断开TCP连接 HTTP的请求方法(HTTP/1.1: Method Definitions)一些get请求方式：1. 直接输入某个地址 2. 点击链接 3. 表单默认提交方式 关于HTTP 响应码(HTTP Status Code )1xx：#临时响应# 代表请求已经被接受，但需要继续处理。 100 Continue — 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。 101 Switching Protocols — 服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。 102 Processing — 由WebDAV(RFC 2518)扩展的状态码，代表处理将被继续执行。2xx：#成功# 代表请求已经被服务器接收、理解、并接受 200 OK：请求成功(其后是对GET和POST请求的应答文档。) 201 Created — 请求被创建完成，同时新的资源被创建。 202 Accepted — 供处理的请求已被接受，但是处理未完成。 203 Non-authoritative Information — 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。 204 No Content — 没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 205 Reset Content — 没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。 206 Partial Content — 客户发送了一个带有Range头的GET请求，服务器完成了它。 207 Multi-Status — 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。3xx: #重定向# 代表客户端需要采取进一步的操作才能完成请求 300 Multiple Choices — 多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。 301 Moved Permanently — 所请求的页面已经转移至新的url。 302 Found — 所请求的页面已经临时转移至新的url。 303 See Other — 所请求的页面可在别的url下被找到。 304 Not Modified — 未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求(一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档)。服务器告诉客户，原来缓冲的文档还可以继续使用。 305 Use Proxy — 客户请求的文档应该通过Location头所指明的代理服务器提取。 306 Unused — 此代码被用于前一版本。目前已不再使用，但是代码依然被保留。 307 Temporary Redirect — 被请求的页面已经临时移至新的url。4xx：#客户端错误# 代表客户端可能发生了错误，阻碍了服务器的处理， 400 Bad Request — 服务器未能理解请求或是请求参数有误。 401 Unauthorized — 被请求的页面需要用户名和密码。 402 Payment Required — 此代码尚无法使用(为了将来可能的需求而预留的。) 403 Forbidden — 对被请求页面的访问被禁止。 404 Not Found — 服务器无法找到被请求的页面。 405 Method Not Allowed — 请求中指定的方法不被允许。 406 Not Acceptable — 服务器生成的响应无法被客户端所接受。 407 Proxy Authentication Required — 用户必须首先使用代理服务器进行验证，这样请求才会被处理。 408 Request Timeout — 请求超出了服务器的等待时间。 409 Conflict — 由于冲突，请求无法被完成。 410 Gone — 被请求的页面不可用。 411 Length Required”Content-Length — “ 未被定义。如果无此内容，服务器不会接受请求。 412 Precondition Failed — 请求中的前提条件被服务器评估为失败。 413 Request Entity Too Large — 由于所请求的实体的太大，服务器不会接受请求。 414 Request-url Too Long — 由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。 415 Unsupported Media Type — 由于媒介类型不被支持，服务器不会接受请求。 416 — 服务器不能满足客户在请求中指定的Range头。 417 Expectation Failed5xx： #服务器错误# 代表服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。 500 Internal Server Error — 请求未完成。服务器遇到不可预知的情况。 501 Not Implemented — 请求未完成。服务器不支持所请求的功能。 502 Bad Gateway — 请求未完成。服务器从上游服务器收到一个无效的响应。 503 Service Unavailable — 请求未完成。服务器临时过载或当机。 504 Gateway Timeout — 网关超时。 505 HTTP Version Not Supported — 服务器不支持请求中指明的HTTP协议版本。 HTTP1.1与HTTP1.1的区别(Key Differences between HTTP/1.0 and HTTP/1.1)最大的区别：HTTP1.0规定浏览器与服务器只保持短暂的链接，每次请求需要建立TCP连接，完成后立即断开；HTTP1.1支持持久连接，一个连接可用于多次响应请求交换，允许客户端不用等待上一次结果返回，就可以发送下一个请求。 总结：博客要坚持写，小问题也可以写写。","categories":[{"name":"Font-end","slug":"font-end","permalink":"https://irisgithub.github.io/categories/font-end/"}],"tags":[]},{"title":"去掉jQuery","date":"2017-04-01T07:59:49.000Z","path":"2017/04/01/去掉jQuery/","text":"一直在Angular中混用jQuery，用来操作DOM，因为它(wo)很(tai)方(nian)便(qing)，最近将jQuery从项目中移除了，将所有涉及到jQuery操作换为用angular提供的api或原生js来实现……虽然jQuery压缩过才100kb左右。1.Angular内置jqLite，封装了部分操作DOM的api，使用angular.element(ele)相当于jQuery中的$,具体使用见官方文档。因此我们所使用的jQuery选择器，例如： $(\"#empl-name\").val(); 可以换成： angular.element(document.querySelector(\"#empl-name\")); 使用document.querySelector 的原因官方文档中有说明: 2.替换掉依赖jQuery的插件。例如，使用的jQuery的tooltip组件插件，现在换成ui bootstrap中的tooltip组件。原来引入jQuery tooltip插件代码后，封装成指令： \"use strict\"; var moduleName=\"kass.widget.tooltip\"; angular.module(moduleName,[]) .directive(\"tooltip\",[function(){ return{ restrict : \"A\", link : function(scope, element, attrs){//element:指令标签对象 attrs:指令属性 var opts ={ //将带有tooltip属性的\"Target element\"传给插件创建tooltip formatter: function(scope){ return scope.$target.attr(\"tooltip\");//$target是利用$(this)封装的jquery对象 }, //插件提供的tooltip属性值direction与指令属性tooltipDirection direction : attrs.tooltipDirection ? attrs.tooltipDirection : \"bottom\" }; //插件提供的tipper方法设置tooltip属性值 element.tipper(opts); element.one(\"$destroy\",function(){ element.tipper(\"destroy\"); }); } } }]); module.exports=moduleName; 引入ui bootstrap 中的tooptip部分： require(\"./position\");//ui bootstrap的position部分 require(\"./stackedMap\");//ui bootstrap的stackedMap部分 angular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap',\"uib/template/tooltip/tooltip-html-popup.html\",\"uib/template/tooltip/tooltip-popup.html\",\"uib/template/tooltip/tooltip-template-popup.html\"]) .provider('$uibTooltip', function(){........}) ...... .directive('uibTooltipTemplatePopup', function() { return { restrict: 'A', scope: { contentExp: '&amp;', originScope: '&amp;' }, templateUrl: 'uib/template/tooltip/tooltip-template-popup.html' }; }); ...... angular.module(\"uib/template/tooltip/tooltip-popup.html\", []).run(......); ...... angular.module('ui.bootstrap.tooltip').run(......); 发现github上的一个封装angular tooltip的项目,使用方便有demo,⊙o⊙…… 3.jQuery的动画部分。一些动画可以直接使用css的animation、transition属性进行设置，还可以使用angular提供的动画。例如jQuery一个简单的改变位置动画，需要在动画完成后移除这个指令组件： $(\".side-modal\").animate({right:'-100%'},300,function(){ $scope.$apply(function(){ $scope.onRemove(); }); }); 使用angular的动画，要引入angular-animate.js文件，注入ngAnimate： \"use strict\"; require(\"./angular-animte-min\"); var moduleName = \"animateTest\"; angular.module(moduleName,[\"ngAnimate\"]) .directive(myTest,[\"$animate\",function(\"$animate\"){ return{ restrict : \"AE\", replace : false, scope : { onRemove : \"&amp;\" }, template : require(\"html!../template/to/mytest.html\"), controller : [\"$scope\",function($scope){ ...... var slideBox = angular.element(document.querySelector(\".side-modal\")); $animate.addClass(slideBox,'set-right',function(){ $scope.onRemove();//callback,动画完成后移除指令 }); ...... }], link:function(scope,element,attrs){......} } }]); module.exports=moduleName; 4.其他部分可以参考github上的一个项目：You Don’t Need jQuery。 April Fool’s Day ….⊙o⊙….","categories":[{"name":"Font-end","slug":"font-end","permalink":"https://irisgithub.github.io/categories/font-end/"}],"tags":[{"name":"JavaScript","slug":"js","permalink":"https://irisgithub.github.io/tags/js/"}]},{"title":"git学习记录","date":"2017-03-17T09:09:02.000Z","path":"2017/03/17/git学习记录/","text":"公司一直用的是svn（集中式版本控制系统 ），一般日常提交代码用update（从中央服务器上获取最新代码）和commit（将本地代码提交上去，提交前会用Beyond Compare软件对比修改一下）两个命令就能满足一般需求，偶尔会看一下日志，用一下版本回滚。但是最近搭博客，开始使用github，了解到git（分布式版本控制系统）好像很火？大家都在推荐，于是用了一下这个新工具。 首先，如果你想详细了解git原理和使用，狠狠点击这里！此外，还有很多关于git不同风格的博客啊，比如廖雪峰写的git教程。但是，如果你口味清奇有趣，可以选择这个，敲生动，适合食用！ 然后，列一下学习记录： 先学点简单的： 1.网上下载安装git，得到大礼包：Git Bash，Git GUI，Git CMD，一般操作使用Git Bash即可。2.本地新建文件，使用git init将它变成待用仓库。 3.获取代码： git clone &lt;server url&gt; //将远程仓库 上的代码拉到仓库中。 4.修改代码后，这样提交它： git add &lt;filename&gt; //提交 到缓存区（index） 或者使用： git add . //提交 所有改动文件到缓存区 再将其提交到本地仓库中： git commit -m \"修改信息\" //提交到本地仓库中的HEAD上 期间，你可以用git status查看文件变化。 下图是我修改blog中的文件时，git status返回的文件状态 git push origin master //提交到远程仓库origin 如果你没有进行第3步，这里使用： git remote add origin &lt;server url&gt; //提交到远程仓库 5.我们经常要将远程仓库中的代码更新本地： git pull 满足基本的需求后，我们了解一下git的分支功能： 1.创建、查看、切换分支： git branch newbranch //新建一个名newbranch的分支 git checkout -b newbranch //新建一个名newbranch的分支并切换到新分支 git branch //查看分支 git checkout master //回到主分支master 然后就可以在确定的分支下操作（比如上方的基础操作）。 2.进行分支间的操作，比如： git branch -d newbranch //删除这个分支 git merge &lt;branchname&gt; //合并分支到当前分支 来一张learngitbranch的图： 此时可能产生冲突，用git status查看情况，再去文件修改解决冲突，用git add 将冲突的文件标记为解决，再用git status确认冲突被解决，然后我们就可以用git commit提交了。 当然除了分支，git还有很多功能（标签，撤销操作，版本回退），当有其他情况可以去查找命令，以上。","categories":[{"name":"Font-end","slug":"font-end","permalink":"https://irisgithub.github.io/categories/font-end/"}],"tags":[]},{"title":"从零到gulp","date":"2017-03-16T09:13:27.000Z","path":"2017/03/16/从零到gulp/","text":"本菜刚开始写前端页面，目录是这样的，js放一起，html放一起：然后，我开始学nwjs啦，多了一个package.json文件（plugins打算用来放插件，是空的；.log文件打算用node的file模块写入日志），之后本菜默默开始写登录小窗，菜单，托盘，然后…写完demo明白自己很菜开始好好学js。 开始刷书，刷博客，刷代码，看小伙伴们的代码…于是我开始写简单页面啦，开始用jquery（获取和操作DOM元素，写ajax请求），angularjs，最初目录是这样：开始安装node，利用npm管理模块，学着小伙伴用webpack，一个入口index.js文件，功能分开写再打包成一个js文件；装fis3，更改代码可以自动刷新页面，目录变成这样：开始好好学angularjs，路由，数据绑定，指令，师傅组装的ui组件…发现自己真的菜，好多知识要学，嗯！舍弃fis3（文件多了，release变慢，-wL要等好久），用http-server，目录变成这样：然后，发现gulp,新大陆！添加一个gulpfile.js文件，用gulp-connect创建web服务器；可以watch页面，gulp-livereload自动刷新；嵌入原来的webpack.config.js还能继续打包；只用运行一个gulp，开心！ 某一天，我发现我的cpu原来是这样：开了gulp之后，变成这样： ……… 我想这一定是我的错！ ……… 最后发现用gulp来watch时一定不要加很多文件啊！只watch经常改变的。不然电脑变得超级卡，还以为自己一脚把主机踢坏了(⊙v⊙)…..就酱！ 感谢师傅！ —-2017-4-30 更新—-gulp + webpack2，附上gulpfile.js的代码： var gulp = require('gulp'), gutil = require('gulp-util'), clean = require('gulp-clean'), concat = require('gulp-concat'), cssmin = require('gulp-cssmin'), connect = require('gulp-connect'), livereload = require('gulp-livereload'), webpack = require('webpack'), webpackConfig = require('./webpack.config.js'); //创建连接 gulp.task('connect',function(){ connect.server({ root : \"./\", ip : \"192.168.1.77\", port : 8080, livereload : true }); }); //图片和iconfont到拷贝到assets gulp.task('copy:images', function (done) { gulp.src(['./admin/static/img/**/*']).pipe(gulp.dest('./admin/assets/img')) .on('end', done); gulp.src(['./admin/static/font/*']).pipe(gulp.dest('./admin/assets/font')) .on('end', done); }); //合并压缩css到assets gulp.task('min:css', function (done) { gulp.src(['./admin/static/css/*.css']) .pipe(concat('./style.min.css')) .pipe(cssmin()) .pipe(gulp.dest('./admin/assets/css/')) .on('end', done); }); //监听文件变化 gulp.task('watch', function(done){ livereload.listen(); gulp.watch('./admin/assets/**/*',['build-admin'],function(file){ livereload.changed(file.path); }).on('end', done); }); //webpack打包 var myDevConfig = Object.create(webpackConfig); var devCompiler = webpack(myDevConfig); gulp.task(\"build-admin\",function(callback){ devCompiler.run(function(err, stats) { if(err) throw new gutil.PluginError(\"webpack:build-admin\", err); gutil.log(\"[webpack:build-admin]\", stats.toString({ colors: true })); callback(); }); }); //build之前clean gulp.task('clean', function(done){ gulp.src(['admin/assets']) .pipe(clean()) .on('end', done); }); gulp.task('default',['connect','copy:images','min:css','watch','build-admin']);","categories":[{"name":"Font-end","slug":"font-end","permalink":"https://irisgithub.github.io/categories/font-end/"}],"tags":[]},{"title":"JS对字符串操作","date":"2017-03-02T10:44:08.000Z","path":"2017/03/02/JS对字符串操作/","text":"截取字符串：1.split： 把一个字符串分割成字符串数组。 功能 ：使用一个指定的分隔符把字符串分隔存储到数组语法 ：str.split(separator,size)参数 ： str：必选项。要截取的字符串。 separator: 必选项。要分割的条件，是字符串或表达式。 size：可选项。返回数组的长度。不定义则全部返回。 实例 ：1var str=”jpg|bmp|gif|ico|png”; arr=str.split(”|”);//arr是一个包含字符值”jpg”、”bmp”、”gif”、”ico”和”png”的数组 2.slice： 提取字符串的某个部分。 功能：返回一个新的数组，包含从start到end（不包括该元素）的arrayobject中的元素。语法：str.slice(startPos,endPos)参数： startPos: 必选项。字符串的起始位置。如果参数负数，则从字符串的结尾处算起。 也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 endPos: 可选项。提取字符串的结束小标。 如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 实例：12var str='ahji3o3s4e6p8a0sdewqdasj'alert(str.slice(2,5)) //结果ji3 3.substring： 返回指定位置的子字符串。 功能：用于提取字符串中介于两个指定下标之间的字符。语法：str.substring(startPos,endPos)参数： str: 必选项。要提取的字符串。 startPos: 必选项。子字符串的起始位置，该索引从0开始计算。 一个非负的整数，规定要提取的子串的第一个字符在 stringObject 中的位置。 endPos: 可选项。子字符串的结束位置，该索引从0开始计算。 一个非负的整数，比要提取的子串的最后一个字符在 stringObject 中的位置多 1。 如果省略该参数，那么返回的子串会一直到字符串的结尾。 注： 返回 一个新的字符串，该字符串值包含 stringObject 的一个子字符串，其内容是从 start 处到 stop-1 处的所有字符，其长度为 stop 减 start。 说明 substring 方法返回的子串包括 start 处的字符，但不包括 end 处的字符。 如果 start 与 end 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。 如果 start 比 end 大，那么该方法在提取子串之前会先交换这两个参数。 如果 start 或 end 为负数，那么它将被替换为 0。 实例：12str='ahji3o3s4e6p8a0sdewqdasj'alert(str.substring(2,6)) //结果为ji3o3 4.substr: 返回字符串中指定位置开始的指定长度的子字符串。 语法：str.substr(startPos,length)参数： str：必选项。要提取的字符串。 startPos: 必选项。返回字符串的起始位置，单位为数字。 字符串中的第一个字符的索引为 0。为负数，则默认为0 length: 可选项。返回字符串的字符个数。 说明 如果 length 为 0 或负数，将返回一个空字符串。 如果没有指定该参数，则子字符串将延续到stringObject的最后。 实例：123456var str = \"0123456789\";alert(str.substring(5)); //\"56789\"alert(str.substring(10)); //\"\"alert(str.substring(2,12)); //\"23456789\"alert(str.substring(2,-2)); //\"01\"alert(str.substring(-1,5)); //\"01234\" 合并字符串1.join 功能：使用您选择的分隔符将一个数组合并为一个字符串。 实例：123var delimitedString=myArray.join(delimiter);var myList=new Array(”jpg”,”bmp”,”gif”,”ico”,”png”);var portableList=myList.join(”|”);//结果是jpg|bmp|gif|ico|png 2.concat 功能：将两个数组连接在一起。 实例：123arr1=[1,2,3,4]arr2=[5,6,7,8]alert(arr1.concat(arr2)) //结果为[1,2,3,4,5,6,7,8] 其他：1.charAt 功能：返回指定位置的字符。字符串中第一个字符的下标是 0。如果参数 index 不在 0 与 string.length 之间，该方法将返回一个空字符串。 实例:12var str='a,g,i,d,o,v,w,d,k,p'alert(str.charAt(2)) //结果为g 2.charCodeAt 功能：charCodeAt() 方法可返回指定位置的字符的Unicode 编码。这个返回值是 0 - 65535 之间的整数。方法 charCodeAt() 与 charAt() 方法执行的操作相似，只不过前者返回的是位于指定位置的字符的编码，而后者返回的是字符子串。 实例：12var str='a,g,i,d,o,v,w,d,k,p'alert(str.charCodeAt(2)) //结果为103。即g的Unicode编码为103 3.replace: 用于在字符串中用一些字符替换另一些字符。 语法：str.replace(string,replacement)参数： str：必选项。要替换的字符串。 string:必选项。正则对象。 replacement: 必选项。要替换的字符。 —-记录这些是因为某些时候会记错某个方法返回结果，基本用法还是要记一记的，羞愧= =—-","categories":[{"name":"Font-end","slug":"font-end","permalink":"https://irisgithub.github.io/categories/font-end/"}],"tags":[{"name":"JavaScript","slug":"js","permalink":"https://irisgithub.github.io/tags/js/"}]},{"title":"WPF笔记","date":"2017-03-02T10:41:51.000Z","path":"2017/03/02/WPF笔记/","text":"改写窗体：1.WPF中使用默认窗口框架的外观，可以更改属性：(参考)Icon: 指定窗口的图标；Title: 指定窗口的标题；WindowStyle: 指定窗口样式，有4个取值： None，无边框；（当ResizeMode属性为NoResize时，仅剩下窗口核心。） SingleBorderWindow，单边框【默认】； ThreeDBorderWindow，3D边框； ToolBorderWindow，工具箱窗口； ResizeMode 是指定大小调节样式，有4个取值： NoResize，不可调节，同时没有最大最小按钮； CanMinimize，不可调节。但可以最小化；（此时最大化按钮不可用） CanResize，可调节【默认】； CanResizeWithGrid，可根据网格调节；（窗口右下脚显示可调节网格） WindowStartLocation 指定窗口初始位置，有3个取值： Manual，手工指定位置，表示可以通过设置其Top、Left属性值来决定窗口的初始位置； CenterScreen，屏幕中央； CenterOwner，父窗体中央； 另外： MaxWidth、MinWidth、MaxHeight、MinHeight ：表示窗口最大宽度、最小宽度、最大高度、最小高度。可以通过得到和更改这些属性值，来获取和改变窗口的大小和长宽范围。 TitlebarHeight=”45” //修改窗体titlebar高度； AllowsTransparency：获取或设置一个值，该值指示窗口的工作区是否支持透明； 2.设置窗体无边框： 设置 WindowStyle=”None”、 AllowsTransparency=”True” 即可。 如下：12345678910&lt;Window x:Class=\"WpfApplication1.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Title=\"MainWindow\" Height=\"350\" Width=\"525\" WindowStyle=\"None\" AllowsTransparency=\"True\"&gt; &lt;Grid&gt; &lt;/Grid&gt; &lt;/Window&gt; 3.窗口拖放：123private void Window_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)&#123; this.DragMove();&#125; 调用： 1this.MouseLeftButtonDown += delegate &#123; DragMove(); &#125;; 或：123456MouseDown=\"Window_MouseDown\"private void Window_MouseDown(object sender, MouseButtonEventArgs e)&#123; if (e.LeftButton == MouseButtonState.Pressed)&#123; DragMove(); &#125;&#125; 4.自定义窗体最大化、最小化、关闭如下：12345678910111213private void btn_min_Click(object sender, RoutedEventArgs e)&#123; this.WindowState = WindowState.Minimized; &#125;private void btn_max_Click(object sender, RoutedEventArgs e)&#123; if(this.WindowState == WindowState.Maximized)&#123; this.WindowState = WindowState.Normal; //还原 &#125;else&#123; this.WindowState = WindowState.Maximized; &#125;&#125;private void btn_close_Click(object sender, RoutedEventArgs e)&#123; this.Close();&#125; 5.窗口阴影：(WPF4.5)1234567891011121314151617&lt;Window x:Class=\"WPFTest.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Title=\"MainWindow\" Width=\"525\" Height=\"350\"&gt; &lt;WindowChrome.WindowChrome&gt; &lt;WindowChrome CaptionHeight=\"30\" CornerRadius=\"0\" GlassFrameThickness=\"1\" NonClientFrameEdges=\"None\" ResizeBorderThickness=\"5\" UseAeroCaptionButtons=\"False\" /&gt; &lt;/WindowChrome&gt; &lt;Grid&gt; &lt;/Grid&gt;&lt;/Window&gt; tooltip给某个空间增加tooltip显示详细信息: 1234567private void Tip_MouseMove(object sender, MouseEventArgs e)&#123; ListViewItem listitem = (sender as Image).TryFindParent&lt;ListViewItem&gt;(); FDObject item = (FDObject)listitem.DataContext; if (item != null)&#123; (sender as Image).ToolTip = item.path; &#125;&#125; 直接用control.Tooltip=text; 在鼠标移入事件中确定 System.Drawing.Image对象System.Drawing.Image 和 System.Windows.Media.ImageSource 之间转换例：123456789MemoryStream ms = new MemoryStream ();var bitmap = new BitmapImage();bitmap.BeginInit();userImage.Save (ms,System.Drawing.Imaging. ImageFormat.Bmp);ms.Seek(0, SeekOrigin.Begin);bitmap.StreamSource = ms;bitmap.EndInit();emplImage.Source = bitmap;return emplImage; 旋转动画：例：123456789101112 private void Button_Click(object sender, RoutedEventArgs e)&#123; RotateTransform a = new RotateTransform(); Refresh.RenderTransform = a; Refresh.RenderTransformOrigin = new Point(0.5, 0.5); DoubleAnimation myDouble = new DoubleAnimation(0, 360, new Duration(TimeSpan.FromSeconds(1))); Storyboard story = new Storyboard(); myDouble.RepeatBehavior = RepeatBehavior.Forever; story.Children.Add(myDouble); Storyboard.SetTarget(myDouble, Refresh); Storyboard.SetTargetProperty(myDouble, new PropertyPath(\"RenderTransform.Angle\")); story.Begin();&#125; 1234&lt;Grid&gt; &lt;TextBlock x:Name=\"Refresh\" VerticalAlignment=\"Center\" HorizontalAlignment=\"Center\" Text=\"&amp;#xe712;\" /&gt; &lt;Button VerticalAlignment=\"Bottom\" HorizontalAlignment=\"Center\" Width=\"100\" Height=\"50\" Click=\"Button_Click\"/&gt;&lt;/Grid&gt;","categories":[{"name":"Others","slug":"others","permalink":"https://irisgithub.github.io/categories/others/"}],"tags":[{"name":"WPF","slug":"wpf","permalink":"https://irisgithub.github.io/tags/wpf/"}]},{"title":"my first blog","date":"2017-03-02T08:40:04.000Z","path":"2017/03/02/my-first-blog/","text":"博客由hexo+github搭建，遵循markdown语法来编辑博客，网上教程很多，比较简单。博客内容来自于印象笔记，从我的小本本上选一些搬出来，(⊙v⊙)嗯！","categories":[{"name":"Others","slug":"others","permalink":"https://irisgithub.github.io/categories/others/"}],"tags":[]}]